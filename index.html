<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Shot Visualizer – Team 1700</title>
  <style>
    * { margin: 0; padding: 0; box-sizing: border-box; }
    body {
      font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
      display: flex; height: 100vh; overflow: hidden;
      background: #0d1117; color: #c9d1d9;
    }

    /* ── Sidebar ─────────────────────────────────────── */
    #sidebar {
      width: 320px; min-width: 320px;
      background: #161b22; border-right: 1px solid #30363d;
      overflow-y: auto; padding: 16px;
      display: flex; flex-direction: column; gap: 16px;
    }
    #sidebar h1 {
      font-size: 18px; font-weight: 600; color: #58a6ff;
      border-bottom: 1px solid #30363d; padding-bottom: 8px;
    }
    .control-group {
      background: #0d1117; border: 1px solid #30363d; border-radius: 8px; padding: 12px;
    }
    .control-group h2 {
      font-size: 13px; font-weight: 600; color: #58a6ff;
      text-transform: uppercase; letter-spacing: 0.5px; margin-bottom: 8px;
    }
    .control-row {
      display: flex; align-items: center; gap: 8px; margin-bottom: 6px;
    }
    .control-row:last-child { margin-bottom: 0; }
    .control-row label {
      font-size: 12px; color: #8b949e; min-width: 90px; flex-shrink: 0;
    }
    .control-row input[type="range"] { flex: 1; min-width: 0; }
    .control-row .value {
      font-size: 12px; color: #e6edf3; min-width: 52px; text-align: right;
      font-variant-numeric: tabular-nums;
    }
    .mode-toggle {
      display: flex; gap: 4px; margin-bottom: 8px;
    }
    .mode-toggle button {
      flex: 1; padding: 4px 8px; font-size: 11px; font-weight: 600;
      border: 1px solid #30363d; border-radius: 4px;
      background: #0d1117; color: #8b949e; cursor: pointer;
      transition: all 0.15s;
    }
    .mode-toggle button.active {
      background: #1f6feb; color: #fff; border-color: #1f6feb;
    }
    select {
      background: #0d1117; color: #c9d1d9; border: 1px solid #30363d;
      border-radius: 4px; padding: 3px 6px; font-size: 12px; flex: 1;
    }
    #status {
      font-size: 11px; color: #8b949e; text-align: center; padding: 4px;
    }

    /* ── Canvas area ─────────────────────────────────── */
    #canvas-container {
      flex: 1; position: relative; overflow: hidden;
    }
    #field-canvas { display: block; width: 100%; height: 100%; }
    #tooltip {
      position: absolute; pointer-events: none; display: none;
      background: rgba(22, 27, 34, 0.95); border: 1px solid #30363d;
      border-radius: 6px; padding: 8px 10px; font-size: 12px;
      line-height: 1.5; white-space: nowrap; z-index: 10;
      box-shadow: 0 4px 12px rgba(0,0,0,0.4);
    }
    #tooltip .tt-header { color: #58a6ff; font-weight: 600; margin-bottom: 2px; }
    #tooltip .tt-valid { color: #3fb950; }
    #tooltip .tt-invalid { color: #f85149; }
    #tooltip .tt-row { color: #c9d1d9; }

    /* ── Shot Modal ────────────────────────────────────── */
    #shot-modal-backdrop {
      position: fixed; inset: 0; z-index: 100;
      background: rgba(0, 0, 0, 0.7);
      display: flex; align-items: center; justify-content: center;
    }
    #shot-modal {
      background: #161b22; border: 1px solid #30363d; border-radius: 10px;
      width: min(92vw, 1100px); height: min(88vh, 780px);
      display: flex; flex-direction: column; overflow: hidden;
      box-shadow: 0 8px 32px rgba(0,0,0,0.6);
    }
    #shot-modal-header {
      display: flex; align-items: center; justify-content: space-between;
      padding: 10px 16px; border-bottom: 1px solid #30363d;
    }
    #shot-modal-title {
      font-size: 14px; font-weight: 600; color: #58a6ff;
    }
    #shot-modal-close {
      background: none; border: none; color: #8b949e; font-size: 22px;
      cursor: pointer; padding: 0 4px; line-height: 1;
    }
    #shot-modal-close:hover { color: #f85149; }
    #shot-modal-grid {
      flex: 1 1 0; display: grid; grid-template-columns: 1fr 1fr;
      grid-template-rows: 1fr 1fr; gap: 4px; padding: 6px;
      min-height: 0; overflow: hidden;
    }
    .shot-panel {
      background: #0d1117; border: 1px solid #21262d; border-radius: 6px;
      display: flex; flex-direction: column; overflow: hidden;
      min-height: 0; min-width: 0; cursor: pointer;
      transition: border-color 0.15s;
    }
    .shot-panel:hover { border-color: #58a6ff55; }
    .shot-panel.expanded {
      grid-column: 1 / -1; grid-row: 1 / -1; z-index: 2;
      border-color: #58a6ff; cursor: default;
    }
    .shot-panel.collapsed { display: none; }
    .shot-panel-label {
      font-size: 10px; font-weight: 600; color: #8b949e;
      text-transform: uppercase; letter-spacing: 0.5px;
      padding: 4px 8px; border-bottom: 1px solid #21262d; flex-shrink: 0;
    }
    .shot-panel.expanded .shot-panel-label { font-size: 11px; padding: 6px 10px; }
    .shot-panel canvas {
      display: block; width: 100%; flex: 1 1 0; min-height: 0;
    }
    #shot-info {
      flex: 1 1 0; padding: 10px 12px; font-size: 12px; line-height: 1.8;
      color: #c9d1d9; overflow-y: auto; min-height: 0;
    }
    #shot-info .si-label { color: #8b949e; display: inline-block; min-width: 110px; }
    #shot-info .si-val { color: #e6edf3; font-variant-numeric: tabular-nums; }
    #shot-info .si-section {
      color: #58a6ff; font-weight: 600; font-size: 11px;
      text-transform: uppercase; margin-top: 6px; margin-bottom: 2px;
      border-bottom: 1px solid #21262d; padding-bottom: 2px;
    }

    /* ── Slider styling ──────────────────────────────── */
    input[type="range"] {
      -webkit-appearance: none; height: 4px; border-radius: 2px;
      background: #30363d; outline: none;
    }
    input[type="range"]::-webkit-slider-thumb {
      -webkit-appearance: none; width: 14px; height: 14px;
      border-radius: 50%; background: #58a6ff; cursor: pointer;
    }
    input[type="range"]::-moz-range-thumb {
      width: 14px; height: 14px; border-radius: 50%;
      background: #58a6ff; cursor: pointer; border: none;
    }
  </style>
</head>
<body>

<!-- ═══════════════════ SIDEBAR ═══════════════════ -->
<div id="sidebar">
  <h1>Shot Visualizer – 1700</h1>

  <!-- Shot Speed -->
  <div class="control-group">
    <h2>Shot Speed</h2>
    <div class="mode-toggle" data-group="speed">
      <button class="active" data-mode="variable">Variable</button>
      <button data-mode="fixed">Fixed</button>
    </div>
    <div id="speed-variable">
      <div class="control-row">
        <label>Min Speed</label>
        <input type="range" id="minSpeed" min="1" max="30" step="0.1" value="8.5">
        <span class="value" id="minSpeed-val">8.5 m/s</span>
      </div>
      <div class="control-row">
        <label>Max Speed</label>
        <input type="range" id="maxSpeed" min="1" max="30" step="0.1" value="21.3">
        <span class="value" id="maxSpeed-val">21.3 m/s</span>
      </div>
    </div>
    <div id="speed-fixed" style="display:none;">
      <div class="control-row">
        <label>Shot Speed</label>
        <input type="range" id="fixedSpeed" min="1" max="30" step="0.1" value="15">
        <span class="value" id="fixedSpeed-val">15.0 m/s</span>
      </div>
    </div>
  </div>

  <!-- Hood Angle -->
  <div class="control-group">
    <h2>Hood Angle</h2>
    <div class="mode-toggle" data-group="angle">
      <button class="active" data-mode="variable">Variable</button>
      <button data-mode="fixed">Fixed</button>
    </div>
    <div id="angle-variable">
      <div class="control-row">
        <label>Min Angle</label>
        <input type="range" id="minAngle" min="5" max="85" step="0.5" value="5">
        <span class="value" id="minAngle-val">5.0°</span>
      </div>
      <div class="control-row">
        <label>Max Angle</label>
        <input type="range" id="maxAngle" min="5" max="85" step="0.5" value="85">
        <span class="value" id="maxAngle-val">85.0°</span>
      </div>
    </div>
    <div id="angle-fixed" style="display:none;">
      <div class="control-row">
        <label>Hood Angle</label>
        <input type="range" id="fixedAngle" min="5" max="85" step="0.5" value="45">
        <span class="value" id="fixedAngle-val">45.0°</span>
      </div>
    </div>
  </div>

  <!-- Robot Velocity -->
  <div class="control-group" id="robot-velocity-group">
    <h2>Robot Velocity</h2>
    <div class="control-row">
      <label>Tangential</label>
      <input type="range" id="tangentialVelo" min="0" max="5" step="0.1" value="0">
      <span class="value" id="tangentialVelo-val">0.0 m/s</span>
    </div>
    <div class="control-row">
      <label>Radial</label>
      <input type="range" id="radialVelo" min="-3" max="3" step="0.1" value="0">
      <span class="value" id="radialVelo-val">0.0 m/s</span>
    </div>
  </div>

  <!-- Visualization -->
  <div class="control-group">
    <h2>Visualization</h2>
    <div class="control-row">
      <label>View</label>
      <div class="mode-toggle" data-group="view" style="flex:1; margin-bottom:0;">
        <button class="active" data-mode="field">Field Map</button>
        <button data-mode="range">Range Chart</button>
      </div>
    </div>
    <div class="control-row">
      <label>Color Mode</label>
      <select id="colorMode">
        <option value="speed">Shot Speed</option>
        <option value="angle">Hood Angle</option>
      </select>
    </div>
    <div class="control-row">
      <label>Grid Res.</label>
      <input type="range" id="gridRes" min="0.1" max="0.5" step="0.05" value="0.2">
      <span class="value" id="gridRes-val">0.20 m</span>
    </div>
    <div class="control-row">
      <label>Shooter Z</label>
      <input type="range" id="shooterZ" min="0" max="1.0" step="0.01" value="0.48">
      <span class="value" id="shooterZ-val">0.00 m</span>
    </div>
    <div class="control-row">
      <label>Ceiling</label>
      <input type="range" id="ceilingHeight" min="3" max="15" step="0.1" value="7.0">
      <span class="value" id="ceilingHeight-val">7.0 m</span>
    </div>
    <div class="control-row">
      <label>Max Vy @&nbsp;Target</label>
      <input type="range" id="maxVyAtTarget" min="-10" max="0" step="0.1" value="-0.5">
      <span class="value" id="maxVyAtTarget-val">-0.5 m/s</span>
    </div>
  </div>

  <!-- Target -->
  <div class="control-group">
    <h2>Target (Blue Hub)</h2>
    <div class="control-row">
      <label>Target X</label>
      <input type="range" id="targetX" min="0" max="16.54" step="0.01" value="4.625594">
      <span class="value" id="targetX-val">4.63 m</span>
    </div>
    <div class="control-row">
      <label>Target Y</label>
      <input type="range" id="targetY" min="0" max="8.07" step="0.01" value="4.034663">
      <span class="value" id="targetY-val">4.03 m</span>
    </div>
    <div class="control-row">
      <label>Target Z</label>
      <input type="range" id="targetZ" min="0.5" max="4" step="0.01" value="1.60">
      <span class="value" id="targetZ-val">1.60 m</span>
    </div>
  </div>

  <div id="status">Ready</div>

  <button id="copy-link" style="
    width: 100%; padding: 8px 12px; margin-top: auto;
    font-size: 12px; font-weight: 600; cursor: pointer;
    background: #1f6feb; color: #fff; border: none; border-radius: 6px;
    transition: background 0.15s;
  " onmouseover="this.style.background='#388bfd'"
     onmouseout="this.style.background='#1f6feb'">
    Copy Shareable Link
  </button>
</div>

<!-- ═══════════════════ CANVAS ═══════════════════ -->
<div id="canvas-container">
  <canvas id="field-canvas"></canvas>
  <div id="tooltip"></div>
</div>

<!-- ═══════════════════ SHOT MODAL ═══════════════════ -->
<div id="shot-modal-backdrop" style="display:none;">
  <div id="shot-modal">
    <div id="shot-modal-header">
      <span id="shot-modal-title">Shot Trajectory</span>
      <button id="shot-modal-close">&times;</button>
    </div>
    <div id="shot-modal-grid">
      <div class="shot-panel">
        <div class="shot-panel-label">SIDE VIEW &mdash; Range &times; Height</div>
        <canvas id="cv-side"></canvas>
      </div>
      <div class="shot-panel" id="shot-info-panel">
        <div class="shot-panel-label">SHOT PARAMETERS</div>
        <div id="shot-info"></div>
      </div>
      <div class="shot-panel">
        <div class="shot-panel-label">TOP VIEW &mdash; Range &times; Lateral</div>
        <canvas id="cv-top"></canvas>
      </div>
      <div class="shot-panel">
        <div class="shot-panel-label">BACK VIEW &mdash; Lateral &times; Height</div>
        <canvas id="cv-back"></canvas>
      </div>
    </div>
  </div>
</div>

<script>
// ═══════════════════════════════════════════════════════════════
//  CONSTANTS
// ═══════════════════════════════════════════════════════════════
const FIELD_LENGTH = 16.54;  // meters, X dimension (full field)
const FIELD_WIDTH  = 8.07;   // meters, Y dimension
const GRAVITY      = 9.8;
const DISPLAY_BUFFER = 1.5;  // meters past target to show on field view

// ═══════════════════════════════════════════════════════════════
//  STATE
// ═══════════════════════════════════════════════════════════════
let heatmapData = null;       // 2D array of results (field view)
let rangeChartData = null;    // range chart results
let rangeChartLayout = {};    // range chart layout for tooltip hit-testing
let layoutCache = {};         // canvas layout geometry
let currentParams = {};       // current control values
let recalcTimer = null;

function getViewMode() {
  const btn = document.querySelector('[data-group="view"] button.active');
  return btn ? btn.dataset.mode : 'field';
}

// ═══════════════════════════════════════════════════════════════
//  PHYSICS ENGINE  (ported from ShotCalculator.java)
// ═══════════════════════════════════════════════════════════════

/**
 * 2D sweep over (speed, angle) to find the best starting point for Newton.
 * Prefers descending trajectories under the ceiling with smallest height error.
 *
 * Directly ported from ShotCalculator.sweepSpeedAndAngle().
 */
function sweepSpeedAndAngle(
    minSpeed, maxSpeed, speedSteps,
    minAngleDeg, maxAngleDeg,
    tangentialVelo, radialVelo,
    range, heightDiff, shooterZ, ceilingHeight
) {
  const minAngle = minAngleDeg * Math.PI / 180;
  const maxAngle = maxAngleDeg * Math.PI / 180;

  let bestSpeed = (minSpeed + maxSpeed) / 2;
  let bestAngle = (minAngle + maxAngle) / 2;
  let bestError = Infinity;
  let foundDescending = false;
  const minDescentRate = -0.5;

  const speedStep = speedSteps > 1 ? (maxSpeed - minSpeed) / (speedSteps - 1) : 0;
  const angleStep = 0.02; // ~1.1°

  for (let si = 0; si < speedSteps; si++) {
    const v = minSpeed + si * speedStep;

    for (let a = minAngle; a <= maxAngle + 0.001; a += angleStep) {
      const angle = Math.min(a, maxAngle);
      const cosA = Math.cos(angle);
      const sinA = Math.sin(angle);

      // Ceiling check: apex = shooterZ + (v·sinθ)² / (2g)
      const vVert = v * sinA;
      const apex = shooterZ + (vVert * vVert) / (2 * GRAVITY);
      if (apex > ceilingHeight) continue;

      const hSpeed = v * cosA;
      const turretAdj = Math.atan2(-tangentialVelo, hSpeed);
      const effSpeed = hSpeed * Math.cos(turretAdj) + radialVelo;
      if (effSpeed <= 0.1) continue;

      const t = range / effSpeed;
      const h = v * sinA * t - 0.5 * GRAVITY * t * t;
      const err = Math.abs(h - heightDiff);
      const vyTarget = v * sinA - GRAVITY * t;
      const desc = vyTarget < minDescentRate;

      if (desc) {
        if (!foundDescending || err < bestError) {
          bestError = err;
          bestSpeed = v;
          bestAngle = angle;
          foundDescending = true;
        }
      } else if (!foundDescending && err < bestError) {
        bestError = err;
        bestSpeed = v;
        bestAngle = angle;
      }

      // Fixed angle: one iteration only
      if (maxAngle - minAngle < 0.002) break;
    }
  }

  return { speed: bestSpeed, angle: bestAngle, error: bestError };
}

/**
 * Newton's-method refinement of launch angle at a fixed speed.
 *
 * Directly ported from ShotCalculator.refineAngle().
 */
function refineAngle(
    speed, initialTheta,
    tangentialVelo, radialVelo,
    range, heightDiff,
    clampMinDeg, clampMaxDeg
) {
  const clampMin = Math.max(clampMinDeg * Math.PI / 180, 0.05);
  const clampMax = Math.min(clampMaxDeg * Math.PI / 180, Math.PI / 2 - 0.05);

  let theta = initialTheta;
  let shotTime = 0;
  let turretAdjRad = 0;

  for (let attempt = 0; attempt < 2; attempt++) {
    for (let i = 0; i < 20; i++) {
      const cosT = Math.cos(theta);
      const sinT = Math.sin(theta);
      const hSpeed = speed * cosT;

      turretAdjRad = Math.atan2(-tangentialVelo, hSpeed);
      const cosTurret = Math.cos(turretAdjRad);
      const effRadSpeed = hSpeed * cosTurret + radialVelo;

      if (effRadSpeed <= 0.1) {
        theta = Math.max(theta - 0.1, clampMin);
        continue;
      }

      shotTime = range / effRadSpeed;
      const h = speed * sinT * shotTime - 0.5 * GRAVITY * shotTime * shotTime;
      const error = h - heightDiff;

      if (Math.abs(error) < 0.001) break;

      // Finite-difference derivative dH/dθ
      const dTheta = 0.0001;
      const cosTp = Math.cos(theta + dTheta);
      const sinTp = Math.sin(theta + dTheta);
      const hSpeedP = speed * cosTp;
      const turretP = Math.atan2(-tangentialVelo, hSpeedP);
      const effP = hSpeedP * Math.cos(turretP) + radialVelo;
      const tP = effP > 0.1 ? range / effP : shotTime;
      const hP = speed * sinTp * tP - 0.5 * GRAVITY * tP * tP;

      const dH = (hP - h) / dTheta;
      if (Math.abs(dH) < 0.0001) break;

      theta -= error / dH;
      theta = Math.max(clampMin, Math.min(clampMax, theta));
    }

    // Check if converged solution is descending
    const vy = speed * Math.sin(theta) - GRAVITY * shotTime;
    if (vy < 0) break; // descending — done

    // Ascending — bump steeper and retry once
    theta = Math.min(theta + 0.15, clampMax);
  }

  return { angle: theta, shotTime, turretAdjRad };
}

/**
 * Evaluate whether a shot from field position (fx, fy) can reach the target.
 * Returns an object with shot details, or null if invalid.
 */
function evaluateShot(fx, fy, p) {
  const dx = p.targetX - fx;
  const dy = p.targetY - fy;
  const range = Math.sqrt(dx * dx + dy * dy);
  const heightDiff = p.targetZ - p.shooterZ;

  if (range < 0.3) return null; // too close to target

  // Determine sweep parameters from mode
  const sMin  = p.speedMode === 'fixed' ? p.fixedSpeed : p.minSpeed;
  const sMax  = p.speedMode === 'fixed' ? p.fixedSpeed : p.maxSpeed;
  const sSteps = p.speedMode === 'fixed' ? 1 : 30;

  const aMin = p.angleMode === 'fixed' ? p.fixedAngle : p.minAngle;
  const aMax = p.angleMode === 'fixed' ? p.fixedAngle : p.maxAngle;

  // Use finer speed sweep when angle is fixed (more resolution needed)
  const actualSpeedSteps = (p.angleMode === 'fixed' && p.speedMode !== 'fixed') ? 30 : sSteps;

  // Sweep
  const sweep = sweepSpeedAndAngle(
    sMin, sMax, actualSpeedSteps,
    aMin, aMax,
    p.tangentialVelo, p.radialVelo,
    range, heightDiff, p.shooterZ, p.ceilingHeight
  );

  let speed = sweep.speed;
  let angle = sweep.angle;

  // Newton refinement (only when angle is variable)
  if (p.angleMode !== 'fixed') {
    const ref = refineAngle(
      speed, angle,
      p.tangentialVelo, p.radialVelo,
      range, heightDiff,
      aMin, aMax
    );
    angle = ref.angle;
  }

  // Final validation
  const cosA = Math.cos(angle);
  const sinA = Math.sin(angle);
  const hSpeed = speed * cosA;
  const turretAdj = Math.atan2(-p.tangentialVelo, hSpeed);
  const effRadSpeed = hSpeed * Math.cos(turretAdj) + p.radialVelo;

  if (effRadSpeed <= 0.1) return null;

  const t = range / effRadSpeed;
  const h = speed * sinA * t - 0.5 * GRAVITY * t * t;
  const heightError = Math.abs(h - heightDiff);

  // Tighter tolerance when Newton was used, looser for fixed angle
  const tolerance = p.angleMode === 'fixed' ? 0.15 : 0.05;
  if (heightError > tolerance) return null;

  const vyAtTarget = speed * sinA - GRAVITY * t;
  const apexHeight = p.shooterZ + (speed * sinA) ** 2 / (2 * GRAVITY);

  if (apexHeight > p.ceilingHeight) return null;

  // Must be descending at least as fast as the threshold (maxVyAtTarget is negative)
  if (vyAtTarget > p.maxVyAtTarget) return null;

  return {
    shotSpeed: speed,
    hoodAngleDeg: angle * 180 / Math.PI,
    flightTime: t,
    vyAtTarget,
    apexHeight,
    heightError,
    range
  };
}


// ═══════════════════════════════════════════════════════════════
//  RANGE CHART COMPUTATION
// ═══════════════════════════════════════════════════════════════

/**
 * Evaluate a shot at a given range (distance to target), bypassing field position.
 * Creates a virtual field position at the correct distance from the target.
 */
function evaluateShotAtRange(range, tangentialVelo, radialVelo, params) {
  const fx = params.targetX + range;
  const fy = params.targetY;
  const modParams = Object.assign({}, params, { tangentialVelo, radialVelo });
  return evaluateShot(fx, fy, modParams);
}

/**
 * Compute range chart data: sweep over distance × tangential velocity × radial velocity.
 * Returns a data object with panels[radialIdx][tanIdx][distIdx] = result | null.
 */
function computeRangeChart(params) {
  const distMin = 0.5, distMax = 10, distStep = 0.25;
  const tanMin = 0, tanMax = 5, tanStep = 0.5;
  const radMin = -3, radMax = 3, radStep = 1;

  const distances = [];
  for (let d = distMin; d <= distMax + 0.001; d += distStep)
    distances.push(Math.round(d * 100) / 100);

  const tangentials = [];
  for (let t = tanMin; t <= tanMax + 0.001; t += tanStep)
    tangentials.push(Math.round(t * 10) / 10);

  const radials = [];
  for (let r = radMin; r <= radMax + 0.001; r += radStep)
    radials.push(Math.round(r * 10) / 10);

  const data = {
    distances, tangentials, radials,
    panels: [],
    minSpeed: Infinity, maxSpeed: -Infinity,
    minAngle: Infinity, maxAngle: -Infinity,
    validCount: 0, totalCount: 0
  };

  for (let ri = 0; ri < radials.length; ri++) {
    const panel = [];
    for (let ti = 0; ti < tangentials.length; ti++) {
      panel[ti] = [];
      for (let di = 0; di < distances.length; di++) {
        const result = evaluateShotAtRange(
          distances[di], tangentials[ti], radials[ri], params
        );
        panel[ti][di] = result;
        data.totalCount++;
        if (result) {
          data.validCount++;
          data.minSpeed = Math.min(data.minSpeed, result.shotSpeed);
          data.maxSpeed = Math.max(data.maxSpeed, result.shotSpeed);
          data.minAngle = Math.min(data.minAngle, result.hoodAngleDeg);
          data.maxAngle = Math.max(data.maxAngle, result.hoodAngleDeg);
        }
      }
    }
    data.panels[ri] = panel;
  }

  return data;
}


// ═══════════════════════════════════════════════════════════════
//  HEATMAP COMPUTATION (Field View)
// ═══════════════════════════════════════════════════════════════

function computeHeatmap(params) {
  const res = params.gridRes;
  const displayLength = Math.min(FIELD_LENGTH, params.targetX + DISPLAY_BUFFER);
  const cols = Math.ceil(displayLength / res);
  const rows = Math.ceil(FIELD_WIDTH / res);

  const data = {
    cols, rows, res, results: [],
    minSpeed: Infinity, maxSpeed: -Infinity,
    minAngle: Infinity, maxAngle: -Infinity,
    validCount: 0
  };

  for (let r = 0; r < rows; r++) {
    data.results[r] = [];
    for (let c = 0; c < cols; c++) {
      const fx = (c + 0.5) * res;
      const fy = (r + 0.5) * res;
      const result = evaluateShot(fx, fy, params);
      data.results[r][c] = result;

      if (result) {
        data.validCount++;
        data.minSpeed = Math.min(data.minSpeed, result.shotSpeed);
        data.maxSpeed = Math.max(data.maxSpeed, result.shotSpeed);
        data.minAngle = Math.min(data.minAngle, result.hoodAngleDeg);
        data.maxAngle = Math.max(data.maxAngle, result.hoodAngleDeg);
      }
    }
  }

  return data;
}


// ═══════════════════════════════════════════════════════════════
//  BOUNDARY REFINEMENT — adaptive subdivision at valid/invalid edges
// ═══════════════════════════════════════════════════════════════

/**
 * After the coarse grid pass, find every null cell that has at least one
 * valid 8-connected neighbor and re-evaluate it on a finer sub-grid.
 * This catches solutions the coarse grid missed near the boundary.
 */
function refineBoundary(data, params) {
  const { cols, rows, res, results } = data;
  const subDiv = 4;               // 4×4 sub-cells per boundary cell
  const subRes = res / subDiv;
  const refined = new Map();      // key "r,c" → subResults[subDiv][subDiv]
  let refinedValidCount = 0;
  let boundaryCellCount = 0;

  for (let r = 0; r < rows; r++) {
    for (let c = 0; c < cols; c++) {
      if (results[r][c] !== null) continue;   // only refine null cells

      // Check 8-connected neighbors for any valid cell
      let hasValidNeighbor = false;
      for (let dr = -1; dr <= 1 && !hasValidNeighbor; dr++) {
        for (let dc = -1; dc <= 1 && !hasValidNeighbor; dc++) {
          if (dr === 0 && dc === 0) continue;
          const nr = r + dr, nc = c + dc;
          if (nr >= 0 && nr < rows && nc >= 0 && nc < cols && results[nr][nc]) {
            hasValidNeighbor = true;
          }
        }
      }
      if (!hasValidNeighbor) continue;

      boundaryCellCount++;
      const baseX = c * res;
      const baseY = r * res;
      const subResults = [];

      for (let sr = 0; sr < subDiv; sr++) {
        subResults[sr] = [];
        for (let sc = 0; sc < subDiv; sc++) {
          const fx = baseX + (sc + 0.5) * subRes;
          const fy = baseY + (sr + 0.5) * subRes;
          const result = evaluateShot(fx, fy, params);
          subResults[sr][sc] = result;

          if (result) {
            refinedValidCount++;
            data.minSpeed = Math.min(data.minSpeed, result.shotSpeed);
            data.maxSpeed = Math.max(data.maxSpeed, result.shotSpeed);
            data.minAngle = Math.min(data.minAngle, result.hoodAngleDeg);
            data.maxAngle = Math.max(data.maxAngle, result.hoodAngleDeg);
          }
        }
      }

      refined.set(`${r},${c}`, subResults);
    }
  }

  data.refined = refined;
  data.subDiv = subDiv;
  data.subRes = subRes;
  data.refinedValidCount = refinedValidCount;
  data.boundaryCellCount = boundaryCellCount;
}


// ═══════════════════════════════════════════════════════════════
//  RENDERING
// ═══════════════════════════════════════════════════════════════

const canvas  = document.getElementById('field-canvas');
const ctx     = canvas.getContext('2d');
const tooltip = document.getElementById('tooltip');

function computeLayout() {
  const targetX = parseFloat(document.getElementById('targetX').value);
  const displayFieldLength = Math.min(FIELD_LENGTH, targetX + DISPLAY_BUFFER);

  const rect = canvas.parentElement.getBoundingClientRect();
  canvas.width  = rect.width  * devicePixelRatio;
  canvas.height = rect.height * devicePixelRatio;
  ctx.setTransform(devicePixelRatio, 0, 0, devicePixelRatio, 0, 0);

  const cw = rect.width;
  const ch = rect.height;
  const pad = 50;
  const legendSpace = 80;
  const availW = cw - pad - legendSpace - pad;
  const availH = ch - 2 * pad;

  const scale = Math.min(availW / displayFieldLength, availH / FIELD_WIDTH);
  const fw = displayFieldLength * scale;
  const fh = FIELD_WIDTH * scale;
  const ox = pad + (availW - fw) / 2;  // left edge of field on canvas
  const oy = pad + (availH - fh) / 2;  // top edge of field on canvas

  layoutCache = { cw, ch, pad, scale, fw, fh, ox, oy, legendX: ox + fw + 20, displayFieldLength };
}

/**
 * Convert field coordinates to canvas pixel coordinates.
 * Field: (0,0) top-right, X left, Y down.
 * Canvas: (0,0) top-left, X right, Y down.
 */
function fieldToCanvas(fx, fy) {
  const { ox, scale, fw } = layoutCache;
  return [
    ox + fw - fx * scale,   // field x=0 → right edge; x=16.54 → left edge
    layoutCache.oy + fy * scale  // field y=0 → top; y=8.07 → bottom
  ];
}

function canvasToField(cx, cy) {
  const { ox, oy, scale, fw } = layoutCache;
  return [
    (fw - (cx - ox)) / scale,
    (cy - oy) / scale
  ];
}

/** HSL-based color ramp for shot speed: blue (low) → red (high) */
function speedColor(t, alpha) {
  const h = 240 - t * 240; // 240=blue → 0=red
  return `hsla(${h}, 85%, 55%, ${alpha})`;
}

/** HSL-based color ramp for hood angle: green (shallow) → orange (steep) */
function angleColor(t, alpha) {
  const h = 130 - t * 100; // 130=green → 30=orange
  return `hsla(${h}, 80%, 50%, ${alpha})`;
}

function render() {
  if (getViewMode() === 'range') { renderRangeChart(); return; }

  const { cw, ch, scale, fw, fh, ox, oy, legendX } = layoutCache;
  const colorMode = document.getElementById('colorMode').value;

  ctx.clearRect(0, 0, cw, ch);

  // ── Field background ──
  ctx.fillStyle = '#0f1f0f';
  ctx.fillRect(ox, oy, fw, fh);

  // ── Heatmap cells ──
  if (heatmapData) {
    const { cols, rows, res, results, minSpeed, maxSpeed, minAngle, maxAngle } = heatmapData;
    const cellW = res * scale;
    const cellH = res * scale;

    for (let r = 0; r < rows; r++) {
      for (let c = 0; c < cols; c++) {
        const result = results[r][c];
        if (!result) continue;

        const fx = (c + 0.5) * res;
        const fy = (r + 0.5) * res;
        const [px, py] = fieldToCanvas(fx, fy);

        let t, color;
        if (colorMode === 'speed') {
          const range = maxSpeed - minSpeed;
          t = range > 0.01 ? (result.shotSpeed - minSpeed) / range : 0.5;
          color = speedColor(t, 0.8);
        } else {
          const range = maxAngle - minAngle;
          t = range > 0.01 ? (result.hoodAngleDeg - minAngle) / range : 0.5;
          color = angleColor(t, 0.8);
        }

        ctx.fillStyle = color;
        ctx.fillRect(px - cellW / 2, py - cellH / 2, cellW, cellH);
      }
    }

    // ── Refined boundary sub-cells ──
    if (heatmapData.refined && heatmapData.refined.size > 0) {
      const { subDiv, subRes, refined } = heatmapData;
      const subCellW = subRes * scale;
      const subCellH = subRes * scale;

      for (const [key, subResults] of refined) {
        const [rStr, cStr] = key.split(',');
        const pr = parseInt(rStr), pc = parseInt(cStr);
        const baseX = pc * res;
        const baseY = pr * res;

        for (let sr = 0; sr < subDiv; sr++) {
          for (let sc = 0; sc < subDiv; sc++) {
            const subResult = subResults[sr][sc];
            if (!subResult) continue;

            const fx = baseX + (sc + 0.5) * subRes;
            const fy = baseY + (sr + 0.5) * subRes;
            const [px, py] = fieldToCanvas(fx, fy);

            let t, color;
            if (colorMode === 'speed') {
              const range = maxSpeed - minSpeed;
              t = range > 0.01 ? (subResult.shotSpeed - minSpeed) / range : 0.5;
              color = speedColor(t, 0.8);
            } else {
              const range = maxAngle - minAngle;
              t = range > 0.01 ? (subResult.hoodAngleDeg - minAngle) / range : 0.5;
              color = angleColor(t, 0.8);
            }

            ctx.fillStyle = color;
            ctx.fillRect(px - subCellW / 2, py - subCellH / 2, subCellW, subCellH);
          }
        }
      }
    }
  }

  // ── Grid lines every 1m ──
  const dfl = layoutCache.displayFieldLength;
  ctx.strokeStyle = 'rgba(60, 100, 60, 0.35)';
  ctx.lineWidth = 0.5;
  for (let x = 0; x <= dfl; x++) {
    const [px] = fieldToCanvas(x, 0);
    ctx.beginPath(); ctx.moveTo(px, oy); ctx.lineTo(px, oy + fh); ctx.stroke();
  }
  for (let y = 0; y <= FIELD_WIDTH; y++) {
    const [, py] = fieldToCanvas(0, y);
    ctx.beginPath(); ctx.moveTo(ox, py); ctx.lineTo(ox + fw, py); ctx.stroke();
  }

  // ── Field border ──
  ctx.strokeStyle = '#3fb950';
  ctx.lineWidth = 2;
  ctx.strokeRect(ox, oy, fw, fh);

  // ── Alliance wall (Blue, right side, field x=0) ──
  const [bx] = fieldToCanvas(0, 0);
  ctx.fillStyle = 'rgba(31, 111, 235, 0.3)';
  ctx.fillRect(bx - 4, oy, 8, fh);

  // ── Center line (only if within display range) ──
  const halfField = FIELD_LENGTH / 2;
  if (halfField <= dfl) {
    const [mx] = fieldToCanvas(halfField, 0);
    ctx.setLineDash([6, 4]);
    ctx.strokeStyle = 'rgba(139, 148, 158, 0.3)';
    ctx.lineWidth = 1;
    ctx.beginPath(); ctx.moveTo(mx, oy); ctx.lineTo(mx, oy + fh); ctx.stroke();
    ctx.setLineDash([]);
  }

  // ── Hub target marker ──
  const tgtX = parseFloat(document.getElementById('targetX').value);
  const tgtY = parseFloat(document.getElementById('targetY').value);
  const [hx, hy] = fieldToCanvas(tgtX, tgtY);

  ctx.beginPath();
  ctx.arc(hx, hy, 8, 0, Math.PI * 2);
  ctx.fillStyle = 'rgba(88, 166, 255, 0.6)';
  ctx.fill();
  ctx.strokeStyle = '#58a6ff';
  ctx.lineWidth = 2;
  ctx.stroke();

  // Crosshair
  ctx.beginPath();
  ctx.moveTo(hx - 12, hy); ctx.lineTo(hx + 12, hy);
  ctx.moveTo(hx, hy - 12); ctx.lineTo(hx, hy + 12);
  ctx.strokeStyle = '#58a6ff';
  ctx.lineWidth = 1;
  ctx.stroke();

  // ── Axis labels ──
  ctx.fillStyle = '#8b949e';
  ctx.font = '11px sans-serif';

  // X labels along bottom
  ctx.textAlign = 'center';
  for (let x = 0; x <= dfl; x += 2) {
    const [px] = fieldToCanvas(x, 0);
    ctx.fillText(x + 'm', px, oy + fh + 16);
  }

  // Y labels along right side
  ctx.textAlign = 'left';
  for (let y = 0; y <= FIELD_WIDTH; y += 2) {
    const [px, py] = fieldToCanvas(0, y);
    ctx.fillText(y + 'm', px + 10, py + 4);
  }

  // Alliance label
  ctx.font = '12px sans-serif';
  ctx.textAlign = 'center';
  ctx.fillStyle = '#58a6ff';
  ctx.fillText('BLUE', bx, oy - 8);

  // ── Legend ──
  if (heatmapData && heatmapData.validCount > 0) {
    const lx = legendX;
    const ly = oy;
    const lw = 18;
    const lh = fh;

    const colorFn = colorMode === 'speed' ? speedColor : angleColor;
    for (let i = 0; i < lh; i++) {
      const t = 1 - i / lh;  // top = high value
      ctx.fillStyle = colorFn(t, 0.9);
      ctx.fillRect(lx, ly + i, lw, 1);
    }

    ctx.strokeStyle = '#30363d';
    ctx.lineWidth = 1;
    ctx.strokeRect(lx, ly, lw, lh);

    ctx.fillStyle = '#c9d1d9';
    ctx.font = '11px sans-serif';
    ctx.textAlign = 'left';

    if (colorMode === 'speed') {
      ctx.fillText(heatmapData.maxSpeed.toFixed(1) + ' m/s', lx + lw + 5, ly + 11);
      ctx.fillText(heatmapData.minSpeed.toFixed(1) + ' m/s', lx + lw + 5, ly + lh);
      ctx.fillText('Speed', lx - 2, ly - 6);
    } else {
      ctx.fillText(heatmapData.maxAngle.toFixed(1) + '°', lx + lw + 5, ly + 11);
      ctx.fillText(heatmapData.minAngle.toFixed(1) + '°', lx + lw + 5, ly + lh);
      ctx.fillText('Angle', lx - 2, ly - 6);
    }

  }
}


// ═══════════════════════════════════════════════════════════════
//  RANGE CHART RENDERER
// ═══════════════════════════════════════════════════════════════

function renderRangeChart() {
  const { cw, ch } = layoutCache;
  const colorMode = document.getElementById('colorMode').value;

  ctx.clearRect(0, 0, cw, ch);

  if (!rangeChartData) return;

  const { distances, tangentials, radials, panels } = rangeChartData;
  const numPanels = radials.length;

  // Layout
  const padTop = 24, padBottom = 48, padLeft = 80, padRight = 90;
  const legendW = 18, legendGap = 20;
  const gapBetweenPanels = 4;
  const labelHeight = 16;

  const availW = cw - padLeft - padRight - legendW - legendGap - 40;
  const totalVertOverhead = numPanels * labelHeight + (numPanels - 1) * gapBetweenPanels;
  const availH = ch - padTop - padBottom - totalVertOverhead;
  const panelH = Math.max(20, availH / numPanels);

  const cellW = availW / distances.length;
  const cellH = panelH / tangentials.length;

  // Store layout for tooltip hit-testing
  const panelPositions = [];
  for (let ri = 0; ri < numPanels; ri++) {
    const py = padTop + ri * (panelH + labelHeight + gapBetweenPanels);
    panelPositions.push({ labelY: py, heatY: py + labelHeight, ri });
  }
  rangeChartLayout = {
    padLeft, availW, panelH, cellW, cellH,
    panelPositions, distances, tangentials, radials
  };

  // Draw each panel
  for (let ri = 0; ri < numPanels; ri++) {
    const { labelY, heatY } = panelPositions[ri];
    const panel = panels[ri];

    // Panel label
    ctx.fillStyle = '#c9d1d9';
    ctx.font = '11px sans-serif';
    ctx.textAlign = 'left';
    const radLabel = radials[ri] > 0 ? `+${radials[ri].toFixed(0)}` :
                     radials[ri] === 0 ? ' 0' : radials[ri].toFixed(0);
    ctx.fillText(`Radial: ${radLabel} m/s`, padLeft, labelY + labelHeight - 4);

    // Background
    ctx.fillStyle = '#0f1f0f';
    ctx.fillRect(padLeft, heatY, availW, panelH);

    // Heatmap cells
    for (let ti = 0; ti < tangentials.length; ti++) {
      for (let di = 0; di < distances.length; di++) {
        const result = panel[ti][di];
        if (!result) continue;

        let t, color;
        if (colorMode === 'speed') {
          const range = rangeChartData.maxSpeed - rangeChartData.minSpeed;
          t = range > 0.01 ? (result.shotSpeed - rangeChartData.minSpeed) / range : 0.5;
          color = speedColor(t, 0.85);
        } else {
          const range = rangeChartData.maxAngle - rangeChartData.minAngle;
          t = range > 0.01 ? (result.hoodAngleDeg - rangeChartData.minAngle) / range : 0.5;
          color = angleColor(t, 0.85);
        }

        ctx.fillStyle = color;
        // tangential=0 at bottom, tangential=max at top
        const cellY = heatY + panelH - (ti + 1) * cellH;
        const cellX = padLeft + di * cellW;
        ctx.fillRect(cellX, cellY, cellW + 0.5, cellH + 0.5);
      }
    }

    // Panel border
    ctx.strokeStyle = '#30363d';
    ctx.lineWidth = 1;
    ctx.strokeRect(padLeft, heatY, availW, panelH);

    // Y-axis labels (tangential velocity) — show a few per panel
    ctx.fillStyle = '#8b949e';
    ctx.font = '10px sans-serif';
    ctx.textAlign = 'right';
    const tanLabelStep = Math.max(1, Math.ceil(tangentials.length / 4));
    for (let ti = 0; ti < tangentials.length; ti += tanLabelStep) {
      const y = heatY + panelH - (ti + 0.5) * cellH;
      ctx.fillText(tangentials[ti].toFixed(1), padLeft - 4, y + 3);
    }
    // Always show the last label
    const lastTi = tangentials.length - 1;
    const lastY = heatY + panelH - (lastTi + 0.5) * cellH;
    ctx.fillText(tangentials[lastTi].toFixed(1), padLeft - 4, lastY + 3);
  }

  // X-axis labels (distance)
  const lastPanel = panelPositions[numPanels - 1];
  const bottomY = lastPanel.heatY + panelH;
  ctx.fillStyle = '#8b949e';
  ctx.font = '11px sans-serif';
  ctx.textAlign = 'center';

  const distLabelStep = Math.max(1, Math.ceil(distances.length / 15));
  for (let di = 0; di < distances.length; di += distLabelStep) {
    const x = padLeft + (di + 0.5) * cellW;
    ctx.fillText(distances[di].toFixed(1), x, bottomY + 14);
  }

  // Axis titles
  ctx.fillStyle = '#58a6ff';
  ctx.font = '12px sans-serif';
  ctx.textAlign = 'center';
  ctx.fillText('Distance to Target (m)', padLeft + availW / 2, bottomY + 34);

  // Y-axis title (rotated)
  ctx.save();
  const midY = padTop + (bottomY - padTop) / 2;
  ctx.translate(14, midY);
  ctx.rotate(-Math.PI / 2);
  ctx.fillText('Tangential Velocity (m/s)', 0, 0);
  ctx.restore();

  // Legend
  const legendX = padLeft + availW + legendGap;
  const legendTop = panelPositions[0].heatY;
  const legendH = bottomY - legendTop;

  if (rangeChartData.validCount > 0 && legendH > 10) {
    const colorFn = colorMode === 'speed' ? speedColor : angleColor;
    for (let i = 0; i < legendH; i++) {
      const t = 1 - i / legendH;
      ctx.fillStyle = colorFn(t, 0.9);
      ctx.fillRect(legendX, legendTop + i, legendW, 1);
    }

    ctx.strokeStyle = '#30363d';
    ctx.lineWidth = 1;
    ctx.strokeRect(legendX, legendTop, legendW, legendH);

    ctx.fillStyle = '#c9d1d9';
    ctx.font = '11px sans-serif';
    ctx.textAlign = 'left';

    if (colorMode === 'speed') {
      ctx.fillText(rangeChartData.maxSpeed.toFixed(1) + ' m/s', legendX + legendW + 5, legendTop + 11);
      ctx.fillText(rangeChartData.minSpeed.toFixed(1) + ' m/s', legendX + legendW + 5, legendTop + legendH);
      ctx.fillText('Speed', legendX - 2, legendTop - 6);
    } else {
      ctx.fillText(rangeChartData.maxAngle.toFixed(1) + '°', legendX + legendW + 5, legendTop + 11);
      ctx.fillText(rangeChartData.minAngle.toFixed(1) + '°', legendX + legendW + 5, legendTop + legendH);
      ctx.fillText('Angle', legendX - 2, legendTop - 6);
    }
  }
}


// ═══════════════════════════════════════════════════════════════
//  TOOLTIP
// ═══════════════════════════════════════════════════════════════

canvas.addEventListener('pointermove', (e) => {
  const rect = canvas.parentElement.getBoundingClientRect();
  const cx = e.clientX - rect.left;
  const cy = e.clientY - rect.top;

  let html = '';

  if (getViewMode() === 'range') {
    // ── Range chart tooltip ──
    if (!rangeChartData || !rangeChartLayout.panelPositions) {
      tooltip.style.display = 'none'; return;
    }
    const { padLeft, availW, panelH, cellW, cellH, panelPositions,
            distances, tangentials, radials } = rangeChartLayout;

    // Find which panel the mouse is in
    let hitPanel = null;
    for (const p of panelPositions) {
      if (cy >= p.heatY && cy < p.heatY + panelH) { hitPanel = p; break; }
    }
    if (!hitPanel || cx < padLeft || cx > padLeft + availW) {
      tooltip.style.display = 'none'; return;
    }

    // Convert to data indices (tangential 0 at bottom)
    const relY = (hitPanel.heatY + panelH) - cy;
    const ti = Math.floor(relY / cellH);
    const di = Math.floor((cx - padLeft) / cellW);

    if (ti < 0 || ti >= tangentials.length || di < 0 || di >= distances.length) {
      tooltip.style.display = 'none'; return;
    }

    const result = rangeChartData.panels[hitPanel.ri][ti][di];
    const radVal = radials[hitPanel.ri];
    const radSign = radVal > 0 ? '+' : radVal === 0 ? '' : '';

    html = `<div class="tt-header">Dist: ${distances[di].toFixed(2)} m · Tan: ${tangentials[ti].toFixed(1)} m/s · Rad: ${radSign}${radVal.toFixed(1)} m/s</div>`;
    if (result) {
      html += `<div class="tt-valid">✓ Valid Shot</div>`;
      html += `<div class="tt-row">Speed: ${result.shotSpeed.toFixed(1)} m/s</div>`;
      html += `<div class="tt-row">Hood Angle: ${result.hoodAngleDeg.toFixed(1)}°</div>`;
      html += `<div class="tt-row">Flight Time: ${result.flightTime.toFixed(3)} s</div>`;
      html += `<div class="tt-row">Apex: ${result.apexHeight.toFixed(2)} m</div>`;
      html += `<div class="tt-row">Vy at target: ${result.vyAtTarget.toFixed(2)} m/s ↓</div>`;
    } else {
      html += `<div class="tt-invalid">✗ No Valid Shot</div>`;
    }

  } else {
    // ── Field map tooltip ──
    const [fx, fy] = canvasToField(cx, cy);

    if (fx < 0 || fx > (layoutCache.displayFieldLength || FIELD_LENGTH) || fy < 0 || fy > FIELD_WIDTH) {
      tooltip.style.display = 'none'; return;
    }

    let result = null;
    let cellFx = fx, cellFy = fy;
    if (heatmapData) {
      const col = Math.floor(fx / heatmapData.res);
      const row = Math.floor(fy / heatmapData.res);
      if (row >= 0 && row < heatmapData.rows && col >= 0 && col < heatmapData.cols) {
        result = heatmapData.results[row][col];
        cellFx = (col + 0.5) * heatmapData.res;
        cellFy = (row + 0.5) * heatmapData.res;

        if (!result && heatmapData.refined) {
          const subResults = heatmapData.refined.get(`${row},${col}`);
          if (subResults) {
            const subCol = Math.min(heatmapData.subDiv - 1,
              Math.max(0, Math.floor((fx - col * heatmapData.res) / heatmapData.subRes)));
            const subRow = Math.min(heatmapData.subDiv - 1,
              Math.max(0, Math.floor((fy - row * heatmapData.res) / heatmapData.subRes)));
            result = subResults[subRow][subCol];
            cellFx = col * heatmapData.res + (subCol + 0.5) * heatmapData.subRes;
            cellFy = row * heatmapData.res + (subRow + 0.5) * heatmapData.subRes;
          }
        }
      }
    }

    html = `<div class="tt-header">Cell: (${cellFx.toFixed(2)}, ${cellFy.toFixed(2)}) m</div>`;
    if (result) {
      html += `<div class="tt-valid">✓ Valid Shot</div>`;
      html += `<div class="tt-row">Speed: ${result.shotSpeed.toFixed(1)} m/s</div>`;
      html += `<div class="tt-row">Hood Angle: ${result.hoodAngleDeg.toFixed(1)}°</div>`;
      html += `<div class="tt-row">Flight Time: ${result.flightTime.toFixed(3)} s</div>`;
      html += `<div class="tt-row">Range: ${result.range.toFixed(2)} m</div>`;
      html += `<div class="tt-row">Apex: ${result.apexHeight.toFixed(2)} m</div>`;
      html += `<div class="tt-row">Vy at target: ${result.vyAtTarget.toFixed(2)} m/s ↓</div>`;
    } else {
      html += `<div class="tt-invalid">✗ No Valid Shot</div>`;
    }
  }

  tooltip.innerHTML = html;
  tooltip.style.display = 'block';

  // Position tooltip avoiding edge overflow
  const ttRect = tooltip.getBoundingClientRect();
  let tx = e.clientX - rect.left + 14;
  let ty = e.clientY - rect.top - 10;
  if (tx + ttRect.width > rect.width) tx = e.clientX - rect.left - ttRect.width - 14;
  if (ty + ttRect.height > rect.height) ty = rect.height - ttRect.height - 4;
  if (ty < 4) ty = 4;

  tooltip.style.left = tx + 'px';
  tooltip.style.top  = ty + 'px';
});

canvas.parentElement.addEventListener('pointerleave', () => {
  tooltip.style.display = 'none';
});


// ═══════════════════════════════════════════════════════════════
//  SHOT TRAJECTORY MODAL — 3-VIEW POPUP
// ═══════════════════════════════════════════════════════════════

/**
 * Build a detailed shot object from a basic result + velocity context.
 * Generates trajectory points and all derived vectors for the 3-view drawing.
 */
function computeDetailedShot(result, tangentialVelo, radialVelo, params) {
  const speed = result.shotSpeed;
  const angleRad = result.hoodAngleDeg * Math.PI / 180;
  const cosA = Math.cos(angleRad);
  const sinA = Math.sin(angleRad);
  const hSpeed = speed * cosA;
  const vLaunch = speed * sinA;

  const turretAdjRad = Math.atan2(-tangentialVelo, hSpeed);
  const effRadSpeed = hSpeed * Math.cos(turretAdjRad) + radialVelo;

  // Lateral velocity: turret compensates for tangential motion, but not perfectly
  const lateralVelo = hSpeed * Math.sin(turretAdjRad) + tangentialVelo;

  const range = result.range;
  const flightTime = result.flightTime;
  const shooterZ = params.shooterZ;
  const targetZ = params.targetZ;
  const ceilingHeight = params.ceilingHeight;

  // Parametric trajectory: sample 60 points
  const steps = 60;
  const trajectory = [];
  for (let i = 0; i <= steps; i++) {
    const t = (i / steps) * flightTime;
    const x = effRadSpeed * t;                                   // along line of fire
    const z = shooterZ + vLaunch * t - 0.5 * GRAVITY * t * t;   // height
    const y = lateralVelo * t;                                   // lateral drift (after turret compensation)
    trajectory.push({ x, z, y, t });
  }

  // Velocity at launch (in the shooter's reference frame, projected into world)
  const vxLaunch = effRadSpeed;         // radial component of horizontal speed
  const vzLaunch = vLaunch;             // vertical
  const vyLaunch = lateralVelo;         // residual lateral speed (small after turret comp)

  // Velocity at target
  const vxTarget = effRadSpeed;
  const vzTarget = result.vyAtTarget;   // vertical descent velocity
  const vyTarget = lateralVelo;         // lateral (same throughout, no lateral forces)

  // Apex time and position
  const tApex = vLaunch / GRAVITY;
  const xApex = effRadSpeed * tApex;
  const zApex = result.apexHeight;

  return {
    speed, angleRad, hoodAngleDeg: result.hoodAngleDeg,
    hSpeed, vLaunch, turretAdjRad, effRadSpeed,
    range, flightTime, shooterZ, targetZ, ceilingHeight,
    tangentialVelo, radialVelo,
    trajectory,
    vxLaunch, vzLaunch, vyLaunch,
    vxTarget, vzTarget, vyTarget,
    tApex, xApex, zApex,
    apexHeight: result.apexHeight,
    vyAtTarget: result.vyAtTarget,
  };
}


// ── Drawing Utilities ────────────────────────────────────────

/** Draw an arrow from (x1,y1) to (x2,y2) with optional label. */
function drawArrow(c, x1, y1, x2, y2, color, label, headSize) {
  headSize = headSize || 10;
  const dx = x2 - x1, dy = y2 - y1;
  const len = Math.sqrt(dx * dx + dy * dy);
  if (len < 1) return;
  const ang = Math.atan2(dy, dx);

  c.save();
  c.strokeStyle = color;
  c.fillStyle = color;
  c.lineWidth = 2.5;
  c.beginPath();
  c.moveTo(x1, y1);
  c.lineTo(x2, y2);
  c.stroke();

  // Arrowhead
  c.beginPath();
  c.moveTo(x2, y2);
  c.lineTo(x2 - headSize * Math.cos(ang - 0.45), y2 - headSize * Math.sin(ang - 0.45));
  c.lineTo(x2 - headSize * Math.cos(ang + 0.45), y2 - headSize * Math.sin(ang + 0.45));
  c.closePath();
  c.fill();

  // Label — bold, larger, with dark background for readability
  if (label) {
    c.font = 'bold 12px sans-serif';
    c.textAlign = 'center';
    c.textBaseline = 'bottom';
    const mx = (x1 + x2) / 2, my = (y1 + y2) / 2;
    // Offset perpendicular to the arrow
    const nx = -dy / len * 14, ny = dx / len * 14;
    const lx = mx + nx, ly = my + ny;
    // Text background
    const metrics = c.measureText(label);
    const tw = metrics.width + 6, th = 14;
    c.fillStyle = 'rgba(13, 17, 23, 0.85)';
    c.fillRect(lx - tw / 2, ly - th, tw, th);
    c.fillStyle = color;
    c.fillText(label, lx, ly - 1);
  }
  c.restore();
}

/** Draw an arc to show an angle, with optional label. */
function drawAngleArc(c, cx, cy, r, startAngle, endAngle, color, label) {
  c.save();
  c.strokeStyle = color;
  c.lineWidth = 2;
  c.beginPath();
  c.arc(cx, cy, r, startAngle, endAngle, endAngle < startAngle);
  c.stroke();
  if (label) {
    const mid = (startAngle + endAngle) / 2;
    const lx = cx + (r + 14) * Math.cos(mid);
    const ly = cy + (r + 14) * Math.sin(mid);
    c.font = 'bold 12px sans-serif';
    c.textAlign = 'center';
    c.textBaseline = 'middle';
    // Text background
    const metrics = c.measureText(label);
    const tw = metrics.width + 6, th = 14;
    c.fillStyle = 'rgba(13, 17, 23, 0.85)';
    c.fillRect(lx - tw / 2, ly - th / 2, tw, th);
    c.fillStyle = color;
    c.fillText(label, lx, ly);
  }
  c.restore();
}

/** Set up a canvas for HiDPI and return {ctx, w, h} in CSS pixels. */
function prepCanvas(canvasEl) {
  const rect = canvasEl.getBoundingClientRect();
  const w = rect.width, h = rect.height;
  canvasEl.width = w * devicePixelRatio;
  canvasEl.height = h * devicePixelRatio;
  const c = canvasEl.getContext('2d');
  c.setTransform(devicePixelRatio, 0, 0, devicePixelRatio, 0, 0);
  return { c, w, h };
}


// ── Side View (Range × Height) ──────────────────────────────

function renderSideView(canvasEl, shot) {
  const { c, w, h } = prepCanvas(canvasEl);
  const pad = { top: 20, bottom: 30, left: 40, right: 20 };
  const pw = w - pad.left - pad.right;
  const ph = h - pad.top - pad.bottom;

  // World bounds — scale to trajectory, only include ceiling if apex is close to it
  const xMax = shot.range * 1.08;
  const showCeiling = shot.zApex >= 6;
  const zMax = showCeiling
    ? Math.max(shot.ceilingHeight * 1.02, shot.zApex + 1)
    : shot.zApex + 1;
  const zMin = 0;
  const scaleX = pw / xMax;
  const scaleZ = ph / (zMax - zMin);
  const sc = Math.min(scaleX, scaleZ);

  // Transform: world → pixel (x right, z up → y down)
  const toX = (wx) => pad.left + wx * sc;
  const toY = (wz) => pad.top + ph - (wz - zMin) * sc;

  // Background
  c.fillStyle = '#0d1117';
  c.fillRect(0, 0, w, h);

  // Ground line
  c.strokeStyle = '#2d4a2d';
  c.lineWidth = 1;
  c.beginPath();
  c.moveTo(toX(0), toY(0));
  c.lineTo(toX(xMax), toY(0));
  c.stroke();

  // Ceiling — only when apex is high enough that ceiling matters
  if (showCeiling) {
    c.setLineDash([6, 4]);
    c.strokeStyle = '#f8514966';
    c.lineWidth = 1;
    c.beginPath();
    c.moveTo(toX(0), toY(shot.ceilingHeight));
    c.lineTo(toX(xMax), toY(shot.ceilingHeight));
    c.stroke();
    c.setLineDash([]);
    c.fillStyle = '#f8514988';
    c.font = '10px sans-serif';
    c.textAlign = 'right';
    c.fillText('ceiling ' + shot.ceilingHeight.toFixed(1) + 'm', toX(xMax) - 4, toY(shot.ceilingHeight) - 4);
  }

  // Trajectory arc
  c.strokeStyle = '#58a6ff';
  c.lineWidth = 2;
  c.beginPath();
  const traj = shot.trajectory;
  c.moveTo(toX(traj[0].x), toY(traj[0].z));
  for (let i = 1; i < traj.length; i++) {
    c.lineTo(toX(traj[i].x), toY(traj[i].z));
  }
  c.stroke();

  // Apex marker
  c.beginPath();
  c.arc(toX(shot.xApex), toY(shot.zApex), 5, 0, Math.PI * 2);
  c.fillStyle = '#f0883e';
  c.fill();
  c.fillStyle = '#f0883e';
  c.font = 'bold 12px sans-serif';
  c.textAlign = 'center';
  c.fillText('apex ' + shot.zApex.toFixed(2) + 'm', toX(shot.xApex), toY(shot.zApex) - 10);

  // Shooter dot
  c.beginPath();
  c.arc(toX(0), toY(shot.shooterZ), 6, 0, Math.PI * 2);
  c.fillStyle = '#3fb950';
  c.fill();

  // Target dot/ring
  const tx = toX(shot.range), tz = toY(shot.targetZ);
  c.beginPath();
  c.arc(tx, tz, 8, 0, Math.PI * 2);
  c.strokeStyle = '#58a6ff';
  c.lineWidth = 2.5;
  c.stroke();
  c.beginPath();
  c.arc(tx, tz, 3, 0, Math.PI * 2);
  c.fillStyle = '#58a6ff';
  c.fill();

  // Launch velocity vectors — exaggerated for visibility
  const vScale = Math.min(90, pw * 0.22) / shot.speed;
  const launchPx = toX(0), launchPy = toY(shot.shooterZ);
  drawArrow(c, launchPx, launchPy,
    launchPx + shot.vxLaunch * vScale,
    launchPy - shot.vzLaunch * vScale,
    '#3fb950', shot.speed.toFixed(1) + ' m/s');

  // Horizontal component
  drawArrow(c, launchPx, launchPy,
    launchPx + shot.effRadSpeed * vScale,
    launchPy,
    '#3fb950aa', 'h: ' + shot.effRadSpeed.toFixed(1) + ' m/s');

  // Vertical component
  drawArrow(c, launchPx, launchPy,
    launchPx,
    launchPy - shot.vLaunch * vScale,
    '#3fb950aa', 'v: ' + shot.vLaunch.toFixed(1) + ' m/s');

  // Velocity at target (descent) — exaggerated
  const targPx = tx, targPy = tz;
  drawArrow(c, targPx, targPy,
    targPx + shot.vxTarget * vScale,
    targPy - shot.vzTarget * vScale,
    '#f85149', Math.sqrt(shot.vxTarget**2 + shot.vzTarget**2).toFixed(1) + ' m/s');

  // Gravity arrow near apex
  const gLen = 35;
  const gx = toX(shot.xApex) + 25, gy = toY(shot.zApex) + 5;
  drawArrow(c, gx, gy, gx, gy + gLen, '#8b949e', 'g', 7);

  // Hood angle arc at launch — offset right to avoid overlapping velocity labels
  const arcR = 55;
  drawAngleArc(c, launchPx, launchPy, arcR, 0, -shot.angleRad, '#f0883e',
    shot.hoodAngleDeg.toFixed(1) + '\u00B0');

  // Axis labels
  c.fillStyle = '#8b949e';
  c.font = '11px sans-serif';
  c.textAlign = 'center';
  // X-axis ticks
  const xStep = Math.ceil(xMax / 6);
  for (let x = 0; x <= xMax; x += xStep) {
    c.fillText(x + 'm', toX(x), h - 4);
  }
  // Z-axis ticks
  c.textAlign = 'right';
  const zStep = Math.max(1, Math.ceil(zMax / 5));
  for (let z = 0; z <= zMax; z += zStep) {
    c.fillText(z + 'm', pad.left - 4, toY(z) + 3);
  }
}


// ── Top View (Bird's Eye, Range × Lateral) ──────────────────

function renderTopView(canvasEl, shot) {
  const { c, w, h } = prepCanvas(canvasEl);
  const pad = { top: 20, bottom: 30, left: 40, right: 20 };
  const pw = w - pad.left - pad.right;
  const ph = h - pad.top - pad.bottom;

  // World bounds — range on X, lateral on Y
  const xMax = shot.range * 1.08;
  // Lateral drift over flight time
  const maxLateral = Math.abs(shot.tangentialVelo) * shot.flightTime;
  const yExtent = Math.max(maxLateral * 1.5, shot.range * 0.15, 1.0);
  const scaleX = pw / xMax;
  const scaleY = ph / (2 * yExtent);
  const sc = Math.min(scaleX, scaleY);

  // Transform: world x→right, world y→down (lateral), center laterally
  const cx0 = pad.left;
  const cy0 = pad.top + ph / 2;  // lateral=0 center line
  const toX = (wx) => cx0 + wx * sc;
  const toY = (wy) => cy0 + wy * sc;  // positive lateral = downward on screen

  c.fillStyle = '#0d1117';
  c.fillRect(0, 0, w, h);

  // Center line (shooter → target, no drift)
  c.setLineDash([4, 3]);
  c.strokeStyle = '#3fb95044';
  c.lineWidth = 1;
  c.beginPath();
  c.moveTo(toX(0), toY(0));
  c.lineTo(toX(shot.range), toY(0));
  c.stroke();
  c.setLineDash([]);

  // Actual trajectory (top-down projection)
  c.strokeStyle = '#58a6ff';
  c.lineWidth = 2;
  c.beginPath();
  const traj = shot.trajectory;
  c.moveTo(toX(traj[0].x), toY(traj[0].y));
  for (let i = 1; i < traj.length; i++) {
    c.lineTo(toX(traj[i].x), toY(traj[i].y));
  }
  c.stroke();

  // Shooter dot
  c.beginPath();
  c.arc(toX(0), toY(0), 5, 0, Math.PI * 2);
  c.fillStyle = '#3fb950';
  c.fill();

  // Target dot
  c.beginPath();
  c.arc(toX(shot.range), toY(0), 6, 0, Math.PI * 2);
  c.strokeStyle = '#58a6ff';
  c.lineWidth = 2;
  c.stroke();
  c.beginPath();
  c.arc(toX(shot.range), toY(0), 2, 0, Math.PI * 2);
  c.fillStyle = '#58a6ff';
  c.fill();

  // Robot velocity vectors at shooter — exaggerated
  const vMaxComponent = Math.max(1, Math.abs(shot.tangentialVelo), Math.abs(shot.radialVelo), shot.hSpeed);
  const vScale = Math.min(80, pw * 0.18) / vMaxComponent;
  const sx = toX(0), sy = toY(0);

  // Radial velocity (along line of fire = positive X)
  if (Math.abs(shot.radialVelo) > 0.05) {
    drawArrow(c, sx, sy,
      sx + shot.radialVelo * vScale * 3,
      sy,
      '#f0883e', 'radial: ' + shot.radialVelo.toFixed(1) + ' m/s');
  }

  // Tangential velocity (perpendicular = positive Y direction on screen)
  if (Math.abs(shot.tangentialVelo) > 0.05) {
    drawArrow(c, sx, sy,
      sx,
      sy + shot.tangentialVelo * vScale * 3,
      '#da3633', 'tangential: ' + shot.tangentialVelo.toFixed(1) + ' m/s');
  }

  // Turret adjustment angle arc
  if (Math.abs(shot.turretAdjRad) > 0.01) {
    const adjDeg = (shot.turretAdjRad * 180 / Math.PI).toFixed(1);
    drawAngleArc(c, sx, sy, 35, 0, shot.turretAdjRad, '#da3633',
      'turret: ' + adjDeg + '\u00B0');
  }

  // Ball heading vector (the actual direction the ball flies)
  const ballHeading = shot.turretAdjRad;
  const ballVecLen = 70;
  const bhTipX = sx + ballVecLen * Math.cos(ballHeading);
  const bhTipY = sy + ballVecLen * Math.sin(ballHeading);
  drawArrow(c, sx, sy, bhTipX, bhTipY, '#58a6ff', null);
  // Label above the tip so it doesn't collide with other vectors
  c.save();
  c.font = 'bold 12px sans-serif';
  c.fillStyle = 'rgba(13, 17, 23, 0.85)';
  const bhLabel = 'ball heading';
  const bhMetrics = c.measureText(bhLabel);
  c.fillRect(bhTipX - bhMetrics.width / 2 - 3, bhTipY - 28, bhMetrics.width + 6, 16);
  c.fillStyle = '#58a6ff';
  c.textAlign = 'center';
  c.fillText(bhLabel, bhTipX, bhTipY - 15);
  c.restore();

  // Axis labels
  c.fillStyle = '#8b949e';
  c.font = '11px sans-serif';
  c.textAlign = 'center';
  const xStep = Math.ceil(xMax / 6);
  for (let x = 0; x <= xMax; x += xStep) {
    c.fillText(x + 'm', toX(x), h - 4);
  }
  // Lateral axis
  c.textAlign = 'right';
  c.fillText('0', pad.left - 4, cy0 + 3);
  if (yExtent >= 0.5) {
    const yTick = Math.ceil(yExtent);
    c.fillText('+' + yTick + 'm', pad.left - 4, toY(yTick) + 3);
    c.fillText('-' + yTick + 'm', pad.left - 4, toY(-yTick) + 3);
  }
}


// ── Back View (End-On, Lateral × Height) ────────────────────

function renderBackView(canvasEl, shot) {
  const { c, w, h } = prepCanvas(canvasEl);
  const pad = { top: 20, bottom: 30, left: 40, right: 20 };
  const pw = w - pad.left - pad.right;
  const ph = h - pad.top - pad.bottom;

  // World bounds — tighter vertical scaling, conditional ceiling
  const maxLateral = Math.abs(shot.tangentialVelo) * shot.flightTime;
  const yExtent = Math.max(maxLateral * 1.5, 1.0);
  const showCeiling = shot.zApex >= 6;
  const zMax = showCeiling
    ? Math.max(shot.ceilingHeight * 1.02, shot.zApex + 1)
    : shot.zApex + 1;
  const zMin = 0;
  const scaleY = pw / (2 * yExtent);
  const scaleZ = ph / (zMax - zMin);
  const sc = Math.min(scaleY, scaleZ);

  const cx0 = pad.left + pw / 2;   // lateral=0 = center
  const toX = (wy) => cx0 + wy * sc;
  const toY = (wz) => pad.top + ph - (wz - zMin) * sc;

  c.fillStyle = '#0d1117';
  c.fillRect(0, 0, w, h);

  // Ground
  c.strokeStyle = '#2d4a2d';
  c.lineWidth = 1;
  c.beginPath();
  c.moveTo(pad.left, toY(0));
  c.lineTo(pad.left + pw, toY(0));
  c.stroke();

  // Ceiling — only when apex is high enough
  if (showCeiling) {
    c.setLineDash([6, 4]);
    c.strokeStyle = '#f8514966';
    c.lineWidth = 1;
    c.beginPath();
    c.moveTo(pad.left, toY(shot.ceilingHeight));
    c.lineTo(pad.left + pw, toY(shot.ceilingHeight));
    c.stroke();
    c.setLineDash([]);
  }

  // Target ring at center, targetZ height
  const tgtPx = toX(0), tgtPy = toY(shot.targetZ);
  c.beginPath();
  c.arc(tgtPx, tgtPy, 14, 0, Math.PI * 2);
  c.strokeStyle = '#58a6ff44';
  c.lineWidth = 2;
  c.stroke();
  c.beginPath();
  c.arc(tgtPx, tgtPy, 3, 0, Math.PI * 2);
  c.fillStyle = '#58a6ff';
  c.fill();

  // Ball arrival point — lateral drift at target
  const lateralAtTarget = shot.trajectory[shot.trajectory.length - 1].y;
  const ballPx = toX(lateralAtTarget);
  const ballPy = toY(shot.targetZ);

  c.beginPath();
  c.arc(ballPx, ballPy, 5, 0, Math.PI * 2);
  c.fillStyle = '#3fb950';
  c.fill();

  // Descent velocity arrow at ball arrival — purely vertical (downward)
  const vScale = Math.min(70, ph * 0.25) / Math.max(1, Math.abs(shot.vzTarget));
  drawArrow(c, ballPx, ballPy,
    ballPx,
    ballPy - shot.vzTarget * vScale,
    '#f85149', 'Vy: ' + shot.vyAtTarget.toFixed(1) + ' m/s');

  // Trajectory projection (lateral vs height, looking along range axis)
  c.strokeStyle = '#58a6ff44';
  c.lineWidth = 1.5;
  c.beginPath();
  const traj = shot.trajectory;
  c.moveTo(toX(traj[0].y), toY(traj[0].z));
  for (let i = 1; i < traj.length; i++) {
    c.lineTo(toX(traj[i].y), toY(traj[i].z));
  }
  c.stroke();

  // Label target center
  c.fillStyle = '#58a6ff';
  c.font = '11px sans-serif';
  c.textAlign = 'center';
  c.fillText('target', tgtPx, tgtPy + 24);

  // Axis labels
  c.fillStyle = '#8b949e';
  c.font = '11px sans-serif';
  c.textAlign = 'center';
  c.fillText('0', toX(0), h - 4);
  if (yExtent >= 0.5) {
    const yTick = Math.ceil(yExtent);
    c.fillText('+' + yTick + 'm', toX(yTick), h - 4);
    c.fillText('-' + yTick + 'm', toX(-yTick), h - 4);
  }
  c.textAlign = 'right';
  const zStep = Math.max(1, Math.ceil(zMax / 5));
  for (let z = 0; z <= zMax; z += zStep) {
    c.fillText(z + 'm', pad.left - 4, toY(z) + 3);
  }
}


// ── Populate Info Panel ──────────────────────────────────────

function populateShotInfo(shot) {
  const el = document.getElementById('shot-info');
  const row = (label, val) => `<div><span class="si-label">${label}</span><span class="si-val">${val}</span></div>`;
  const section = (title) => `<div class="si-section">${title}</div>`;

  el.innerHTML =
    section('Launch') +
    row('Shot Speed', shot.speed.toFixed(1) + ' m/s') +
    row('Hood Angle', shot.hoodAngleDeg.toFixed(1) + '\u00B0') +
    row('H. Speed', shot.effRadSpeed.toFixed(1) + ' m/s') +
    row('V. Speed', shot.vLaunch.toFixed(1) + ' m/s') +
    row('Turret Adj.', (shot.turretAdjRad * 180 / Math.PI).toFixed(1) + '\u00B0') +
    section('Trajectory') +
    row('Range', shot.range.toFixed(2) + ' m') +
    row('Flight Time', shot.flightTime.toFixed(3) + ' s') +
    row('Apex Height', shot.apexHeight.toFixed(2) + ' m') +
    row('Ceiling', shot.ceilingHeight.toFixed(1) + ' m') +
    section('At Target') +
    row('Vy', shot.vyAtTarget.toFixed(2) + ' m/s') +
    row('Descent Angle', (Math.atan2(-shot.vzTarget, shot.vxTarget) * 180 / Math.PI).toFixed(1) + '\u00B0') +
    section('Robot Velocity') +
    row('Tangential', shot.tangentialVelo.toFixed(1) + ' m/s') +
    row('Radial', shot.radialVelo.toFixed(1) + ' m/s');
}


// ── Open / Close / Expand / Click handler ────────────────────

let currentDetailedShot = null;

/** Map panel elements to their render functions (canvas panels only). */
function getPanelRenderer(panelEl) {
  const cv = panelEl.querySelector('canvas');
  if (!cv) return null;
  if (cv.id === 'cv-side') return renderSideView;
  if (cv.id === 'cv-top')  return renderTopView;
  if (cv.id === 'cv-back') return renderBackView;
  return null;
}

function renderAllPanels(shot) {
  renderSideView(document.getElementById('cv-side'), shot);
  renderTopView(document.getElementById('cv-top'), shot);
  renderBackView(document.getElementById('cv-back'), shot);
}

function openShotModal(shot) {
  currentDetailedShot = shot;
  collapseExpandedPanel();  // reset to 2x2 if anything was expanded

  const backdrop = document.getElementById('shot-modal-backdrop');
  backdrop.style.display = 'flex';

  // Title
  document.getElementById('shot-modal-title').textContent =
    `Shot Trajectory \u2014 ${shot.range.toFixed(1)}m, ${shot.speed.toFixed(1)} m/s, ${shot.hoodAngleDeg.toFixed(1)}\u00B0`;

  // Info panel
  populateShotInfo(shot);

  // Render the three views after a frame so canvases have layout
  requestAnimationFrame(() => renderAllPanels(shot));
}

function closeShotModal() {
  collapseExpandedPanel();
  document.getElementById('shot-modal-backdrop').style.display = 'none';
  currentDetailedShot = null;
}

/** Expand a panel to fill the full grid. */
function expandPanel(panelEl) {
  if (!currentDetailedShot) return;
  const panels = document.querySelectorAll('#shot-modal-grid .shot-panel');
  panels.forEach(p => {
    if (p === panelEl) {
      p.classList.add('expanded');
      p.classList.remove('collapsed');
    } else {
      p.classList.add('collapsed');
      p.classList.remove('expanded');
    }
  });

  // Re-render the expanded canvas at the larger size
  requestAnimationFrame(() => {
    const renderer = getPanelRenderer(panelEl);
    if (renderer) {
      renderer(panelEl.querySelector('canvas'), currentDetailedShot);
    }
  });
}

/** Collapse back to 2x2 grid view. */
function collapseExpandedPanel() {
  const panels = document.querySelectorAll('#shot-modal-grid .shot-panel');
  let wasExpanded = false;
  panels.forEach(p => {
    if (p.classList.contains('expanded') || p.classList.contains('collapsed')) wasExpanded = true;
    p.classList.remove('expanded', 'collapsed');
  });
  if (wasExpanded && currentDetailedShot) {
    requestAnimationFrame(() => renderAllPanels(currentDetailedShot));
  }
}

// Click on a panel to expand, click again to collapse
document.querySelectorAll('#shot-modal-grid .shot-panel').forEach(panel => {
  panel.addEventListener('click', (e) => {
    e.stopPropagation();
    if (panel.classList.contains('expanded')) {
      collapseExpandedPanel();
    } else {
      expandPanel(panel);
    }
  });
});

// Close on backdrop click, close button, Escape key
document.getElementById('shot-modal-backdrop').addEventListener('click', (e) => {
  if (e.target.id === 'shot-modal-backdrop') closeShotModal();
});
document.getElementById('shot-modal-close').addEventListener('click', closeShotModal);
document.addEventListener('keydown', (e) => {
  if (e.key === 'Escape') {
    // If a panel is expanded, collapse first; otherwise close modal
    const expanded = document.querySelector('#shot-modal-grid .shot-panel.expanded');
    if (expanded) {
      collapseExpandedPanel();
    } else {
      closeShotModal();
    }
  }
});

// Click on main canvas to open the modal
canvas.addEventListener('click', (e) => {
  const rect = canvas.parentElement.getBoundingClientRect();
  const cx = e.clientX - rect.left;
  const cy = e.clientY - rect.top;

  let result = null;
  let tangentialVelo = currentParams.tangentialVelo;
  let radialVelo = currentParams.radialVelo;

  if (getViewMode() === 'range') {
    if (!rangeChartData || !rangeChartLayout.panelPositions) return;
    const { padLeft, availW, panelH, cellW, cellH, panelPositions,
            distances, tangentials, radials } = rangeChartLayout;

    let hitPanel = null;
    for (const p of panelPositions) {
      if (cy >= p.heatY && cy < p.heatY + panelH) { hitPanel = p; break; }
    }
    if (!hitPanel || cx < padLeft || cx > padLeft + availW) return;

    const relY = (hitPanel.heatY + panelH) - cy;
    const ti = Math.floor(relY / cellH);
    const di = Math.floor((cx - padLeft) / cellW);
    if (ti < 0 || ti >= tangentials.length || di < 0 || di >= distances.length) return;

    result = rangeChartData.panels[hitPanel.ri][ti][di];
    tangentialVelo = tangentials[ti];
    radialVelo = radials[hitPanel.ri];

  } else {
    const [fx, fy] = canvasToField(cx, cy);
    if (fx < 0 || fx > (layoutCache.displayFieldLength || FIELD_LENGTH) || fy < 0 || fy > FIELD_WIDTH) return;

    if (heatmapData) {
      const col = Math.floor(fx / heatmapData.res);
      const row = Math.floor(fy / heatmapData.res);
      if (row >= 0 && row < heatmapData.rows && col >= 0 && col < heatmapData.cols) {
        result = heatmapData.results[row][col];
        if (!result && heatmapData.refined) {
          const subResults = heatmapData.refined.get(`${row},${col}`);
          if (subResults) {
            const subCol = Math.min(heatmapData.subDiv - 1,
              Math.max(0, Math.floor((fx - col * heatmapData.res) / heatmapData.subRes)));
            const subRow = Math.min(heatmapData.subDiv - 1,
              Math.max(0, Math.floor((fy - row * heatmapData.res) / heatmapData.subRes)));
            result = subResults[subRow][subCol];
          }
        }
      }
    }
  }

  if (!result) return;

  const detailed = computeDetailedShot(result, tangentialVelo, radialVelo, currentParams);
  openShotModal(detailed);
});


// ═══════════════════════════════════════════════════════════════
//  CONTROLS
// ═══════════════════════════════════════════════════════════════

function readParams() {
  const speedBtns = document.querySelectorAll('[data-group="speed"] button');
  const angleBtns = document.querySelectorAll('[data-group="angle"] button');
  const speedMode = [...speedBtns].find(b => b.classList.contains('active')).dataset.mode;
  const angleMode = [...angleBtns].find(b => b.classList.contains('active')).dataset.mode;

  return {
    speedMode,
    minSpeed:       parseFloat(document.getElementById('minSpeed').value),
    maxSpeed:       parseFloat(document.getElementById('maxSpeed').value),
    fixedSpeed:     parseFloat(document.getElementById('fixedSpeed').value),
    angleMode,
    minAngle:       parseFloat(document.getElementById('minAngle').value),
    maxAngle:       parseFloat(document.getElementById('maxAngle').value),
    fixedAngle:     parseFloat(document.getElementById('fixedAngle').value),
    tangentialVelo: parseFloat(document.getElementById('tangentialVelo').value),
    radialVelo:     parseFloat(document.getElementById('radialVelo').value),
    gridRes:        parseFloat(document.getElementById('gridRes').value),
    shooterZ:       parseFloat(document.getElementById('shooterZ').value),
    ceilingHeight:  parseFloat(document.getElementById('ceilingHeight').value),
    targetX:        parseFloat(document.getElementById('targetX').value),
    targetY:        parseFloat(document.getElementById('targetY').value),
    targetZ:        parseFloat(document.getElementById('targetZ').value),
    maxVyAtTarget:  parseFloat(document.getElementById('maxVyAtTarget').value),
  };
}

function updateValueDisplays() {
  document.getElementById('minSpeed-val').textContent       = parseFloat(document.getElementById('minSpeed').value).toFixed(1) + ' m/s';
  document.getElementById('maxSpeed-val').textContent       = parseFloat(document.getElementById('maxSpeed').value).toFixed(1) + ' m/s';
  document.getElementById('fixedSpeed-val').textContent     = parseFloat(document.getElementById('fixedSpeed').value).toFixed(1) + ' m/s';
  document.getElementById('minAngle-val').textContent       = parseFloat(document.getElementById('minAngle').value).toFixed(1) + '°';
  document.getElementById('maxAngle-val').textContent       = parseFloat(document.getElementById('maxAngle').value).toFixed(1) + '°';
  document.getElementById('fixedAngle-val').textContent     = parseFloat(document.getElementById('fixedAngle').value).toFixed(1) + '°';
  document.getElementById('tangentialVelo-val').textContent = parseFloat(document.getElementById('tangentialVelo').value).toFixed(1) + ' m/s';
  document.getElementById('radialVelo-val').textContent     = parseFloat(document.getElementById('radialVelo').value).toFixed(1) + ' m/s';
  document.getElementById('gridRes-val').textContent        = parseFloat(document.getElementById('gridRes').value).toFixed(2) + ' m';
  document.getElementById('shooterZ-val').textContent       = parseFloat(document.getElementById('shooterZ').value).toFixed(2) + ' m';
  document.getElementById('ceilingHeight-val').textContent  = parseFloat(document.getElementById('ceilingHeight').value).toFixed(1) + ' m';
  document.getElementById('targetX-val').textContent        = parseFloat(document.getElementById('targetX').value).toFixed(2) + ' m';
  document.getElementById('targetY-val').textContent        = parseFloat(document.getElementById('targetY').value).toFixed(2) + ' m';
  document.getElementById('targetZ-val').textContent        = parseFloat(document.getElementById('targetZ').value).toFixed(2) + ' m';
  document.getElementById('maxVyAtTarget-val').textContent   = parseFloat(document.getElementById('maxVyAtTarget').value).toFixed(1) + ' m/s';
}

function scheduleRecalc() {
  updateValueDisplays();
  pushStateToUrl();
  clearTimeout(recalcTimer);
  recalcTimer = setTimeout(() => {
    currentParams = readParams();
    document.getElementById('status').textContent = 'Computing...';

    requestAnimationFrame(() => {
      computeLayout();
      const t0 = performance.now();

      if (getViewMode() === 'range') {
        rangeChartData = computeRangeChart(currentParams);
        const dt = (performance.now() - t0).toFixed(0);
        document.getElementById('status').textContent =
          `${rangeChartData.validCount} / ${rangeChartData.totalCount} valid · ${dt} ms`;
      } else {
        heatmapData = computeHeatmap(currentParams);
        refineBoundary(heatmapData, currentParams);
        const dt = (performance.now() - t0).toFixed(0);
        const total = heatmapData.cols * heatmapData.rows;
        const rvc = heatmapData.refinedValidCount || 0;
        const bc = heatmapData.boundaryCellCount || 0;
        let statusText = `${heatmapData.validCount} / ${total} valid`;
        if (bc > 0) statusText += ` · ${bc} edges refined (+${rvc})`;
        statusText += ` · ${dt} ms`;
        document.getElementById('status').textContent = statusText;
      }

      render();
    });
  }, 80);
}

// Mode toggle buttons
document.querySelectorAll('.mode-toggle').forEach(toggle => {
  const group = toggle.dataset.group;
  toggle.querySelectorAll('button').forEach(btn => {
    btn.addEventListener('click', () => {
      toggle.querySelectorAll('button').forEach(b => b.classList.remove('active'));
      btn.classList.add('active');

      if (group === 'speed') {
        document.getElementById('speed-variable').style.display = btn.dataset.mode === 'variable' ? '' : 'none';
        document.getElementById('speed-fixed').style.display    = btn.dataset.mode === 'fixed' ? '' : 'none';
      } else if (group === 'angle') {
        document.getElementById('angle-variable').style.display = btn.dataset.mode === 'variable' ? '' : 'none';
        document.getElementById('angle-fixed').style.display    = btn.dataset.mode === 'fixed' ? '' : 'none';
      } else if (group === 'view') {
        // Hide tangential/radial controls in range mode (they become chart axes)
        document.getElementById('robot-velocity-group').style.display =
          btn.dataset.mode === 'range' ? 'none' : '';
      }

      scheduleRecalc();
    });
  });
});

// All sliders and selects trigger recalc
document.querySelectorAll('#sidebar input[type="range"], #sidebar select').forEach(el => {
  el.addEventListener('input', scheduleRecalc);
});


// ═══════════════════════════════════════════════════════════════
//  DEEP LINKING — URL ↔ Control State
// ═══════════════════════════════════════════════════════════════

/** Map of URL param keys → { element id, type }. Modes handled separately. */
const PARAM_KEYS = {
  minSpeed:       { id: 'minSpeed',       type: 'range' },
  maxSpeed:       { id: 'maxSpeed',       type: 'range' },
  fixedSpeed:     { id: 'fixedSpeed',     type: 'range' },
  minAngle:       { id: 'minAngle',       type: 'range' },
  maxAngle:       { id: 'maxAngle',       type: 'range' },
  fixedAngle:     { id: 'fixedAngle',     type: 'range' },
  tangentialVelo: { id: 'tangentialVelo', type: 'range' },
  radialVelo:     { id: 'radialVelo',     type: 'range' },
  gridRes:        { id: 'gridRes',        type: 'range' },
  shooterZ:       { id: 'shooterZ',       type: 'range' },
  ceilingHeight:  { id: 'ceilingHeight',  type: 'range' },
  targetX:        { id: 'targetX',        type: 'range' },
  targetY:        { id: 'targetY',        type: 'range' },
  targetZ:        { id: 'targetZ',        type: 'range' },
  maxVyAtTarget:  { id: 'maxVyAtTarget',  type: 'range' },
  colorMode:      { id: 'colorMode',      type: 'select' },
};

/** Apply URL search params to the DOM controls. */
function applyUrlParams() {
  const params = new URLSearchParams(window.location.search);
  if (params.size === 0) return;

  // Mode toggles (including view)
  ['speed', 'angle', 'view'].forEach(group => {
    const mode = params.get(group + 'Mode');
    // Validate mode values per group
    const validModes = group === 'view'
      ? ['field', 'range']
      : ['variable', 'fixed'];
    if (mode && validModes.includes(mode)) {
      const toggle = document.querySelector(`[data-group="${group}"]`);
      toggle.querySelectorAll('button').forEach(b => b.classList.remove('active'));
      const target = toggle.querySelector(`[data-mode="${mode}"]`);
      if (target) target.classList.add('active');

      if (group === 'speed') {
        document.getElementById('speed-variable').style.display = mode === 'variable' ? '' : 'none';
        document.getElementById('speed-fixed').style.display    = mode === 'fixed' ? '' : 'none';
      } else if (group === 'angle') {
        document.getElementById('angle-variable').style.display = mode === 'variable' ? '' : 'none';
        document.getElementById('angle-fixed').style.display    = mode === 'fixed' ? '' : 'none';
      } else if (group === 'view') {
        document.getElementById('robot-velocity-group').style.display =
          mode === 'range' ? 'none' : '';
      }
    }
  });

  // Sliders and selects
  for (const [key, { id, type }] of Object.entries(PARAM_KEYS)) {
    const val = params.get(key);
    if (val == null) continue;
    const el = document.getElementById(id);
    if (!el) continue;

    if (type === 'range') {
      const num = parseFloat(val);
      if (!isNaN(num)) {
        const clamped = Math.max(parseFloat(el.min), Math.min(parseFloat(el.max), num));
        el.value = clamped;
      }
    } else {
      // select — only set if the value is a valid option
      const valid = [...el.options].some(o => o.value === val);
      if (valid) el.value = val;
    }
  }
}

/** Write current control state into the URL (replaceState, no reload). */
function pushStateToUrl() {
  const p = new URLSearchParams();

  // Modes
  const speedMode = [...document.querySelectorAll('[data-group="speed"] button')]
    .find(b => b.classList.contains('active'))?.dataset.mode;
  const angleMode = [...document.querySelectorAll('[data-group="angle"] button')]
    .find(b => b.classList.contains('active'))?.dataset.mode;
  const viewMode = getViewMode();
  p.set('speedMode', speedMode);
  p.set('angleMode', angleMode);
  p.set('viewMode', viewMode);

  // Sliders and selects
  for (const [key, { id }] of Object.entries(PARAM_KEYS)) {
    p.set(key, document.getElementById(id).value);
  }

  const url = window.location.pathname + '?' + p.toString();
  history.replaceState(null, '', url);
}

/** Copy the current shareable URL to clipboard. */
document.getElementById('copy-link').addEventListener('click', () => {
  pushStateToUrl();
  const url = window.location.href;
  navigator.clipboard.writeText(url).then(() => {
    const btn = document.getElementById('copy-link');
    const orig = btn.textContent;
    btn.textContent = 'Copied!';
    setTimeout(() => { btn.textContent = orig; }, 1500);
  });
});


// ═══════════════════════════════════════════════════════════════
//  INIT
// ═══════════════════════════════════════════════════════════════

function init() {
  applyUrlParams();        // hydrate controls from URL before anything else
  computeLayout();
  updateValueDisplays();
  currentParams = readParams();

  if (getViewMode() === 'range') {
    rangeChartData = computeRangeChart(currentParams);
    document.getElementById('status').textContent =
      `${rangeChartData.validCount} / ${rangeChartData.totalCount} valid`;
  } else {
    heatmapData = computeHeatmap(currentParams);
    refineBoundary(heatmapData, currentParams);

    const total = heatmapData.cols * heatmapData.rows;
    const rvc = heatmapData.refinedValidCount || 0;
    const bc = heatmapData.boundaryCellCount || 0;
    let statusText = `${heatmapData.validCount} / ${total} valid`;
    if (bc > 0) statusText += ` · ${bc} edges refined (+${rvc})`;
    document.getElementById('status').textContent = statusText;
  }

  render();
  pushStateToUrl();        // normalize the URL on first load
}

window.addEventListener('resize', () => {
  computeLayout();
  render();
});

init();
</script>
</body>
</html>
